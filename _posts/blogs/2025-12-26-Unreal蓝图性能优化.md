---
title: Unreal蓝图性能优化
tags: [Unreal, Blueprint]
categories: [Unreal]
---

### 避免使用 Cast To 蓝图节点
![蓝图节点提示](/images/2025-12-26-Unreal蓝图性能优化/image-1.png)
使用 Cast To 节点会导致蓝图固定加载，带来较高的开销。
_蓝图节点提示_
![Damage_Heal 的尺寸贴图](/images/2025-12-26-Unreal蓝图性能优化/image-2.png)
_Damage_Heal 的尺寸贴图_
![Damage_Heal 蓝图的细节](/images/2025-12-26-Unreal蓝图性能优化/image-3.png){: w="300" .shadow }
_Damage_Heal 蓝图的细节_
Sphere 蓝图只包含一个碰撞体和一个静态网格体，100多MB的内存确实太大了。
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-4.png)
_BP ThirdPersonCharacter 蓝图的细节_
Damage_Heal 蓝图使用 Cast To 节点转化为 BP_ThirdPersonCharacter。查看 BP_ThirdPersonCharacter 的尺寸贴图，发现内存大小几乎等同于 Damage_Heal 使用 Cast To 蓝图节点之后的大小。这进一步验证了 Cast To 节点会带来较高的内存开销的问题。
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-6.png)
_使用GetPlayerCharacter判断当前是否为第三人称角色_
使用 GetPlayerCharacter 节点判断当前是否为第三人称角色，不会产生 Cast To 节点，也不会产生额外的内存开销。

### 避免使用 Event Tick 蓝图节点
Event Tick 触发的事件，每一帧执行一次。假设游戏的 FPS 是 120，那么经过 1 小时，Event Tick 节点会被执行 120 * 60 * 60 = 432000 次。

如上一节所述，一个 Cast To BP_ThirdPersonCharacter 节点，会固定加载 BP_ThirdPersonCharacter，导致 100 多 MB 的内存开销。如果将 Event Tick 节点和 Cast To 节点一起使用，那么每个小时就会产生 432000 * 100MB 的内存开销，约等于 42187 GB。
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-7.png)
_使用自定义事件连接 Set Timer by Event 节点_
那么替代方案是使用带有计时器节点的自定义事件，将自定义事件与 Set Timer by Event 节点连接起来。

### 避免使用 Delay 蓝图节点
Delay 节点本质上在一定时间内暂停了蓝图的执行，这会扰乱游戏的自然流程，并导致帧速率下降。对于多人游戏，不同玩家之间的不同的帧速率以及网络延迟，导致玩家之间的不一致，这会导致不公平的游戏或意外行为。

替代方案和上一节相同，也是使用带有计时器的自定义事件节点。

### 避免使用 Get All Actors of Class 蓝图节点
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-8.png)
_Get All Actors of Class 节点_
使用 Get All Actors of Class 节点，和 Cast To BP_ThirdPersonCharacter 节点相比，后者访问了一个 ThirdPersonCharacter 节点，而前者访问了所有 ThirdPersonCharacter 节点。显然会带来很大的性能损耗。

### 避免绑定函数到 Widgets
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-10.png)
_进图条 Widget 绑定了函数 GetPercent_
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-11.png)
_GetPercent的实现（非常不好的蓝图实现，这里只是为了演示）_
![alt text](/images/2025-12-26-Unreal蓝图性能优化/image-9.png)
_游戏中不断打印 Health 到屏幕_
和 Event Tick 一样，绑定到 Widget 的函数每帧都会执行，同样带来很大的性能损耗。