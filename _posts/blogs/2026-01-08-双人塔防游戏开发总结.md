---
title: 双人塔防游戏开发总结
tags: [Game Dev, 塔防]
mermaid: true
categories: [Game]
---
## 开发环境

### 依赖库
游戏基于 SDL 库和 cJSON 库实现。
```cpp
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>
#include <SDL2_gfxPrimitives.h>

#include <cJSON.h>
```
- SDL.h 文件是 SDL Library 主要的头文件，其引入了纹理数据结构体（表示像素数据）SDL_Texture、渲染器结构体（表示渲染状态）SDL_Renderer、事件结构体（表示事件）SDL_Event 等关键类型。
- SDL_image.h 可以从硬盘上加载图片，通过 IMG_Load 返回 SDL_Surface 类型的数据，或通过 IMG_LoadTexture 返回 SDL_Texture 类型的数据。
- SDL_ttf.h 可以从硬盘上加载字体，通过 TTF_OpenFont 返回 TTF_Font 类型的数据。
- SDL_mixer.h 可以从硬盘上加载音频、播放音效。通过 Mix_LoadWAV 可以返回 Mix_Chunk 类型的数据，或通过 Mix_LoadMUS 返回 Mix_Music 类型的数据。通过 Mix_PlayChannel、Mix_FadeInMusic、Mix_FadeOutMusic 播放音效、音乐。
- SDL2_gfxPrimitives.h 可以在 SDL 渲染器中进行基本图元的绘制，如矩形、圆形等。
- cJSON.h 可以从硬盘上解析 JSON 文件。例如，通过 cJSON_Parse 函数返回 cJSON 类型的 json_root，通过 cJSON_GetObjectItem 函数解析 JSON 文件中的 object 类型的数据。

## 架构主体
游戏主体是一个循环，通过 is_quit 标记控制循环退出。

```cpp
while (!is_quit) {
    ...
}
```

循环中做 3 件事情：1. 获取输入 2. 更新游戏状态 3. 绘制游戏画面。

### 获取输入
获取输入通过 SDL_PollEvent(&event) 函数获取事件，然后通过自定义函数 on_input() 处理事件。

```cpp
while (SDL_PollEvent(&event)) {
	on_input();
}
```

### 更新游戏状态
游戏随时间推进，时间的现实单位为秒，虚拟单位为帧。基于 SDL 库计算时间变化，记为 delta，凭此控制何时推进下一帧。
```cpp
if (delta * 1000 < 1000.0 / 60) {
	SDL_Delay((Uint32)(1000.0 / 60 - delta * 1000));
}
```
自定义帧率是 60，1000.0 / 60 是 1 帧需要多少秒，若当前 delta 推进的时间不到一帧，就延时到下一帧，实现游戏按帧推进。
```cpp
on_update(delta);
```
delta 表示现实经历了多久，将其作为参数传递给自定义的 on_update 函数，可以实现基于现实真实时间推进游戏状态（游戏数据变化）。    

### 绘制游戏画面
```cpp
SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // 设置渲染颜色为黑色不透明
SDL_RenderClear(renderer); // 用设置的颜色清空渲染内容
on_render(); // 自定义绘制函数
SDL_RenderPresent(renderer); // 将 backbuffer 的内容渲染到屏幕上
```
SDL 的渲染函数在 backbuffer 中操作，需要通过 SDL_RenderPresent 函数将其渲染到屏幕上。

上一帧的 backbuffer 在当前帧视为无效，所以，每一帧在渲染前需通过 SDL_RenderClear(renderer) 初始化 backbuffer，然后在 on_render() 中执行自定义的渲染逻辑，最后通过 SDL_RenderPresent(renderer) 将 backbuffer 的内容渲染到屏幕上。

## 架构层次

游戏大致分为 7 个模块，分别为 manager、enemy、bullet、tower、animation、wave 和 ui。
- manager 模块，包括 BulletManager、EnemyManager、TowerManager、HomeManager、ConfigManager……它们有一个共同的基类 Manager。其设计为单例模式，每一个管理单例类都可以通过 instance() 接口获取单例对象，并执行其职责，或者作为容器，存储管理对象。例如：
 - ResourcesManager：负责从硬盘上加载所有的游戏资源，存储在内存中，并通过枚举为每一个资源分配一个唯一的索引，方便资源的获取。
 - ConfigManager: 是游戏的全局数据中心，可以从任意位置通过其单例对象获取数据。其单例对象存储着包括从配置文件中读取的游戏配置、关卡配置，游戏进行中的各种状态标记，游戏地图，防御塔等级等各种数据。
 - GameManager: 是游戏全局控制器，负责游戏全局的初始化、更新、渲染、退出。
 - BulletManager: 负责管理所有子弹，将生成的子弹存入数组，并及时清除失效的子弹。
 - ……
- enemy、bullet、tower模块比较相似，每个模块中，都包含一个基类负责定义通用属性和行为，都包含一个类型类，以及不同类型所对应的子类。
- animation 模块基于定时器推进动画。计时器的 on_timeout 在计时器到时的时候调用，此时可以控制动画是否循环、执行动画一次播放结束之后所绑定的 on_finished 函数。
- wave 模块基于嵌套的定时器逻辑，实现关卡波次的推进，以及每一个波次中敌人生成的推进。
- ui 模块负责游戏界面的绘制，游戏界面独立于游戏内容，需要绘制在游戏内容的上层。

GameManager 是控制游戏进程的顶层类，其 on_input、on_update、on_render 函数分别控制游戏整体的输入处理、数据更新处理、渲染处理。所有需要处理输入的类，需要将其接口调用添加到 GameManager 的 on_input 函数中，所有需要按帧更新数据的类，需要将其接口调用添加到 GameManager 的 on_update 函数中，所有需要渲染的类，需要将其接口调用添加到 GameManager 的 on_render 函数中。

## 游戏逻辑

### 为角色玩家添加技能
1. 在 resources 文件夹中添加技能素材，并通过 ResourcesManager 管理：在 ResID 中添加素材 ID，并通过 SDL 从硬盘加载素材文件。
2. 在 PlayerManager 的构造函数中装配动画。
```cpp
anim_effect_cure.set_loop(false); anim_effect_cure.set_interval(0.1); // 设置循环和间隔
anim_effect_cure.set_frame_data(tex_pool.find(ResID::Tex_CureSmog)->second, 10, 1, { 0,1,2,3,4,5,6,7,8,9 }); // 装配素材到帧数据
anim_effect_cure.set_on_finished([&]() { is_releasing_cure = false; }); // 重置标记
```
3. 在 PlayerManager 的 on_input 函数中添加输入处理，并实现自定义的技能释放函数，例如 on_release_cure()。
```cpp
switch (event.type)
{
case SDL_KEYDOWN:
	switch (event.key.keysym.sym) // event.key.keysym.sym 虚拟的按键键码，在不同的平台上是统一的
	{
		...
	case SDLK_i: // I
		on_release_cure();
		break;
		...
	}
	break;
	...
}
在 on_release_cure() 函数中，包括释放条件检查、配置碰撞箱、更新标记、配置动画（定时器、当前帧）、配置音效等逻辑。
```cpp
void on_release_cure() {

	// 魔法值未满或正在释放技能时，短路返回
	if (mp < 100 || is_releasing_cure)
		return;

	// 根据 player 朝向，更新碰撞箱的位置
	anim_effect_cure_current = &anim_effect_cure;
	switch (facing)
	{
	case Facing::Left:
		rect_hitbox_cure.x = (int)(position.x - size.x / 2 - 68);
		rect_hitbox_cure.y = (int)(position.y - 68 / 2);
		rect_hitbox_cure.w = 68, rect_hitbox_cure.h = 68;
		break;
	case Facing::Right:
		rect_hitbox_cure.x = (int)(position.x + size.x / 2);
		rect_hitbox_cure.y = (int)(position.y - 68 / 2);
		rect_hitbox_cure.w = 68, rect_hitbox_cure.h = 68;
		break;
	case Facing::Up:
		rect_hitbox_cure.x = (int)(position.x - 68 / 2);
		rect_hitbox_cure.y = (int)(position.y - size.y / 2 - 68);
		rect_hitbox_cure.w = 68, rect_hitbox_cure.h = 68;
		break;
	case Facing::Down:
		rect_hitbox_cure.x = (int)(position.x - 68 / 2);
		rect_hitbox_cure.y = (int)(position.y + size.y / 2);
		rect_hitbox_cure.w = 68, rect_hitbox_cure.h = 68;
		break;
	}

	mp = 0;
	is_releasing_cure = true; // 更新标记
	anim_effect_cure_current->reset();

	static const ResourcesManager::SoundPool& sound_pool
		= ResourcesManager::instance()->get_sound_pool();

	Mix_PlayChannel(-1, sound_pool.find(ResID::Sound_Cure)->second, 0); // 根据 ResID 加载音效
}
```
4. 在 PlayerManager 的 on_update 函数中推进动画定时器。
```cpp
void on_update(double delta)
{
	...
	if (is_releasing_cure) {
		anim_effect_cure_current->on_update(delta);
	}
}
```
5. 在 PlayerManager 的 on_render 函数中绘制技能动画。
```cpp
void on_render(SDL_Renderer* renderer)
{
	static SDL_Point point;

	point.x = (int)(position.x - size.x / 2);
	point.y = (int)(position.y - size.y / 2);
	anim_current->on_render(renderer, point);

	...

	if (is_releasing_cure) {
		point.x = rect_hitbox_cure.x;
		point.y = rect_hitbox_cure.y;
		anim_effect_cure_current->on_render(renderer, point);
	}
}
```
