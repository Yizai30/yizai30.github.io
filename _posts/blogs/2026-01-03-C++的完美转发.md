---
title: C++的完美转发
tags: [C++, forward]
categories: [C++, Game Dev]
---

## emplace_back 开发示例
```cpp
typedef std::vector<std::vector<Tile>> TileMap;

TileMap tile_map_temp;

tile_map_temp.emplace_back(); // 新增一行
```
tile_map_temp 存储临时的地图数据。

## 代码分析
其中，emplace_back 函数的实现如下所示：
```cpp
    template <class... _Valty>
    _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {
        // insert by perfectly forwarding into element at end, provide strong guarantee
        _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        (void) _Result;
#endif // _HAS_CXX17
    }
```
emplace_back 函数的实现中，`_Valty&&` 通过引用折叠规则，根据传入的参数 _Val 自动推导类型，... 表示可以接收任何数量的参数，_STD 定义为 ::std:: ，表示从全局命名空间中导入 std 命名空间。

引用折叠规则如下：
- T& & → T&
- T& && → T&
- T&& & → T&
- T&& && → T&&

emplace_back 函数的实现中，`forward` 函数确保了参数保持原始类别（即，保持左值/右值）。可以运行下面的实验代码进行验证：
```cpp
#include <vector>

class Resource {
	std::unique_ptr<int> ptr;
public:
	Resource() = default;
	Resource(const Resource&) = delete;  // 禁止拷贝

	// 移动构造函数
	Resource(Resource&& other)
		: ptr(std::move(other.ptr)) {
	}
};

std::vector<Resource> resources;
Resource r1;

template<typename T>
void my_push(T&& arg) {
	//resources.push_back(std::forward<T>(arg)); // ✅ 正确，使用 foward，保持 arg 是 T&&
	resources.push_back(arg);  // ❌ 编译错误，报错信息是，“Resource::Resource(const Resource &)”: 尝试引用已删除的函数。这是因为 arg 的类型变成了左值，调用了拷贝构造函数
}

int main() {
	my_push(std::move(r1));
    return 0;
}
```

查看 `forward` 的函数实现：
```cpp
_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}
```
其中，static_cast 也通过配合引用折叠规则，使参数保持了左值/右值。

另外，remove_reference_t 的作用是，将参数类型转换为非引用类型。查看其定义：
```cpp
template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

_EXPORT_STD template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;
```
## 总结
完美转发是 C++11 引入的重要特性，通过 std::forward 配合模板的通用引用（即，T&&），以及 static_cast，它们都使用了引用折叠规则，共同作用下，实现了参数的无损传递。